---
title:轉接指南
description: '這個話題說明<strong>轉換</strong>，該過程允許您將視頻編碼為 MP4，然後還將這些視頻重新打包為 HLS 輸出。'
parent: Encoding Guides
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">概述</h2>

    <p>使用Zencoder，您可以將視頻編碼為MP4，然後通過我們稱為“轉碼"（而不是轉碼）的過程將其重新打包為HLS輸出。Transmuxing會將現有的MP4視頻重新打包為HTTP實時流（HLS）所必需的MPEG TS段，而無需重新編碼視頻文件。使用相關輸出，您可以在單個作業中創建H.264文件以及分段文件，從而以更低的成本產生更快的周轉時間。多路復用輸出的費用為編碼成本的1/4。生成的作業將創建6個輸出-2個以您帳戶的常規費率收費，3個以編碼成本的1/4傳輸的多路復用文件和1個免費播放列表。</p>

    <p>為此，您將創建具有兩個主要輸出集（以及播放列表）的單個作業。第一組輸出將是普通的H.264 / AAC MP4文件，並具有一些特殊設置，以使它們可以用作HLS輸出的源文件。第二組輸出將使用那些MP4文件作為“源"輸入，將其內容轉換為HLS輸出。由於這些是從屬輸出，因此它們將等到其相應的源完成後再安排處理。</p>

    <p>該過程的關鍵部分是使用<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a>，是Zencoder API第2版中的新選項。Source告訴輸出使用作業上另一個輸出創建的文件而不是輸入文件來進行處理。在這種情況下，Zencoder將基於輸入文件以請求的比特率創建H.264文件。這些輸出中的每一個完成時，然後將從輸出中創建分段版本。</p>

    <aside class="bcls-aside bcls-aside--information">筆記：如果您無法確保播放流暢，<strong>將transmux和轉碼輸出合併到一個播放列表中</strong>。最佳實踐是需要以相同方式對再現進行編碼。</aside>
  </section>
  <section class="bcls-section">
    <h2 id="h264_outputs">H.264輸出</h2>

    <p>我們將從創建2個H.264文件開始，分別針對高和低比特率。</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "label": "low",
    "format": "mp4",
    "video_bitrate": 200,
    "decoder_bitrate_cap": 300,
    "decoder_buffer_size": 1200,
    "audio_sample_rate": 44100,
    "height": "288",
    "url": "s3://example-bucket/low.mp4",
    "h264_reference_frames": 1,
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56,
    "decimate": 2
},
{
    "label": "high",
    "format": "mp4",
    "video_bitrate": 1000,
    "decoder_bitrate_cap": 1500,
    "decoder_buffer_size": 6000,
    "audio_sample_rate": 44100,
    "height": "432",
    "url": "s3://example-bucket/high.mp4",
    "h264_reference_frames": "auto",
    "h264_profile": "main",
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56
}</code></pre>

    <p>這些輸出產生的文件可以在各種設備上播放。每個目標都有不同的比特率和分辨率，因此可以向用戶發送適當的文件。每個都還適合分段以進行HTTP實時流傳輸並用作自適應比特率流。</p>

    <p>上面的請求中有幾個選項要注意：</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-frame-rate.html#forced-keyframe-rate"><code translate="No">forced_keyframe_rate</code></a>到0.1。這會強制視頻每10秒具有一個關鍵幀。分段文件的長度為10秒，因此可以確保每個分段均以關鍵幀開頭。</li>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-bitrate-cap"><code translate="No">decoder_bitrate_cap</code></a>設置為文件目標比特率的1.5倍。<a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-buffer-size"><code translate="No">decoder_buffer_size</code></a>設置為文件目標比特率的3.5倍到5倍。這些設置將有助於在整個文件中保持一致的比特率，從而使分段的段的大小和比特率變化不大。</li>
    </ul>
    <p>現在已經創建了H.264文件，可以將其他輸出添加到請求中，以從源創建HTTP Live Streaming分段文件，而無需執行其他編碼。</p>
  </section>
  <section class="bcls-section">
    <h2 id="Segmented_Outputs">分段輸出</h2>

    <p>上面的每個H.264視頻和音頻輸出都具有<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#label"><code translate="No">labels</code></a>在其API選項中。這些標籤可以與<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a>選項，告訴Zencoder使用帶有給定標籤的輸出而不是輸入文件使用由輸出創建的視頻。由於H.264文件已經針對HLS進行了良好的設置，因此不需要其他編碼。</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "source": "low",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-low/hls-low.m3u8",
    "label": "hls-low",
    "type": "segmented"
}
{
    "source": "high",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-high/hls-high.m3u8",
    "label": "hls-high",
    "type": "segmented"
}
{
    "streams": [
    {
        "path": "hls-low/hls-low.m3u8",
        "bandwidth": 256
    },
    {
        "path": "hls-high/hls-high.m3u8",
        "bandwidth": 1056
    }
    ],
    "type": "playlist",
    "url": "s3://example-bucket/playlist.m3u8"
}</code></pre>

    <p>這些輸出產生的文件是分段輸出，針對不同的帶寬，再加上一個播放列表文件，供播放設備了解可用的流。</p>

    <p>每個分段的輸出包括<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a>，並指定前面列出的輸出之一。它們還包括<a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-audio"><code translate="No">copy_audio</code></a>和<a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-video"><code translate="No">copy_video</code></a>選項，告訴Zencoder使用源文件中的音頻和視頻流並將它們重新打包到新容器中，而不是對其進行轉碼。最後，輸出還指定了一個<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#type"><code translate="No">type</code></a>的分段和<a href="/encoding-settings/formats-codecs/encoding-settings-format-and-codecs.html#format"><code translate="No">format</code></a> ts，再加上<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#url"><code translate="No">url</code></a>擴展名為.m3u8，因此Zencoder知道可以創建分段的HLS文件。</p>

    <p>最後，還會生成一個引用每個分段輸出的播放列表。請注意，播放列表中引用的第一個文件是低比特率視頻。播放視頻的設備通常會首先加載播放列表中列出的第一個流，然後根據需要切換到其他流。這意味著播放的前10秒將使用此流，在此之後，設備將具有足夠的信息來選擇要播放的適當的流。</p>

    <p><strong>筆記</strong></p>

    <ul>
      <li>HLS播放列表生成當前不使用作業中其他輸出的信息，而只是一種輕鬆生成正確格式的自適應比特率播放列表並將其與其他文件一起上傳的方式。</li>
      <li>雖然iOS設備將播放創建的自適應比特率播放列表，但VLC不會播放，這是因為處理相對URL時出現錯誤。它將在與播放列表文件相同的目錄中而不是清單文件的目錄中查找分段文件。</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Full_request">完整要求</h2>

    <p>現在，我們已經遍歷了每個主要的輸出部分，讓我們將其組合到單個API請求中。</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "s3://zencodertesting/test.mov",
    "outputs": [
    {
        "label": "low",
        "format": "mp4",
        "video_bitrate": 200,
        "decoder_bitrate_cap": 300,
        "decoder_buffer_size": 1200,
        "audio_sample_rate": 44100,
        "height": "288",
        "url": "s3://example-bucket/low.mp4",
        "h264_reference_frames": 1,
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56,
        "decimate": 2
    },
    {
        "label": "high",
        "format": "mp4",
        "video_bitrate": 1000,
        "decoder_bitrate_cap": 1500,
        "decoder_buffer_size": 6000,
        "audio_sample_rate": 44100,
        "height": "432",
        "url": "s3://example-bucket/high.mp4",
        "h264_reference_frames": "auto",
        "h264_profile": "main",
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56
    },
    {
        "source": "low",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-low/hls-low.m3u8",
        "label": "hls-low",
        "type": "segmented"
    }
    {
        "source": "high",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-high/hls-high.m3u8",
        "label": "hls-high",
        "type": "segmented"
    }
    {
        "streams": [
        {
            "path": "hls-low/hls-low.m3u8",
            "bandwidth": 256
        },
        {
            "path": "hls-high/hls-high.m3u8",
            "bandwidth": 1056
        }
        ],
        "type": "playlist",
        "url": "s3://example-bucket/playlist.m3u8"
    }
    ]
}</code></pre>
  </section>
</article>