---
title:100% 集成可靠性
description: '本主題討論您可能無法連接到 Zencoder 的原因以及如何確保可靠集成。'
parent: Integration
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">概述</h2>

    <p>對於大多數客戶而言，Zencoder是必不可少的軟件依賴項。儘管我們的目標是100％的正常運行時間，但有時您可能無法連接到Zencoder：</p>

    <p>當發生這種情況並且 Zencoder 關閉時，您的應用程序通常會從 Zencoder 獲得 '503 服務無法使用的' 響應，但您可能會得到不同的錯誤（如 500）。如果您已超過 API 費率限制，您將獲得「403 超出速率限制」的' 回應。</p>

    <p>好消息：由於視頻編碼是一個異步過程，因此您可以構建應用程序，而不會遇到停機或與我們的可用性有關的問題。如果這樣做，最壞的情況是您的工作需要更長的時間。但是不會發生任何錯誤。我們強烈建議您執行此操作。</p>

    <p>更明確地說，<strong>如果您關心可靠性，則應遵循此方法進行集成</strong> -適用於Zencoder或與之集成的任何關鍵API。</p>

    <ul>
      <li>我們的服務可能會受到上游提供商（例如Amazon Web Services）的問題的影響</li>
      <li>有時我們需要執行需要暫時停機的系統維護</li>
      <li>你已經超過了你的<a href="/general-information/faq-rate-limiting.html">API速率限制</a></li>
      <li>等等。</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Reliable_app_integration">可靠的應用程序集成</h2>

    <ol>
      <li>包括一個<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#secondary-url">次要網址</a>作為備份，以防萬一無法上傳到您的主要位置。</li>
      <li>如果您從Zencoder收到的響應代碼不成功-基本上是200或201以外的其他代碼- <strong>不要讓工作失敗</strong>。響應碼503並不表示您的視頻無法處理。這僅表示Zencoder暫時不可用。</li>
      <li>如果你得到一個<strong>連接錯誤</strong>嘗試連接到Zencoder時，請執行相同的操作。</li>
      <li>相似地，<strong>將您的API請求包裝為超時</strong>。我們建議30秒超時； Zencoder通常會在不到一秒鐘的時間內做出響應，因此30秒通常是足夠的時間。</li>
      <li>在這三種情況下-如果您收到的響應代碼不成功，無法連接或API請求超時- <strong>將作業標記為“待處理"。</strong></li>
      <li>定期<strong>重新提交處於 '擱置' 狀態的任何工作</strong>。例如，您可以使用cron每分鐘執行一次。</li>
    </ol>
    <p>重新提交作業後，所有操作都會像正常情況一樣。這樣，失敗的作業提交只會使作業花費更長的時間，而不會給您的應用程序或用戶帶來麻煩。</p>
  </section>
  <section class="bcls-section">
    <h2 id="Pseudocode">偽碼</h2>

    <p>好的，所以這不是偽代碼-它是Ruby。但是Ruby很容易閱讀。</p>

    <ol>
      <li>想像一個包含這些列的視頻表。（顯然，它會更多，包括用於存儲Zencoder作業ID和Zencoder輸出文件ID的列。）
        <pre class="line-numbers">
<code class="language-ruby" translate="No">create_table :videos do |t|
t.string  :state
t.integer :lock_version
t.index   :state
end</code></pre>
      </li>
      <li>視頻應包括具有以下狀態的狀態機：
        <ul>
          <li>待處理（尚未提交給Zencoder）</li>
          <li>提交（當前正在提交給Zencoder）</li>
          <li>轉碼（已成功提交給Zencoder）</li>
          <li>完成（Zencoder完成轉碼，並且工作完成）</li>
          <li>失敗（Zencoder無法對視頻進行轉碼）</li>
        </ul>
      </li>
      <li>擷取新視訊時，將視訊儲存為「提交' 狀態，並觸發背景工作，將視訊提交至 Zencoder。
        <pre class="line-numbers">
<code class="language-ruby" translate="No"># got a new video!
video = Video.new(params)
video.state = "submitting"
video.save!
submit_to_zencoder(video)</code></pre>

        <p>您確實應該為Submit_to_zencoder方法提供背景。在Ruby中，使用DelayedJob，如下所示：</p>

        <pre class="line-numbers">
<code class="language-ruby" translate="No">delay.submit_to_zencoder(video)</code></pre>

        <p>但是我們會堅持下去<code translate="No">submit_to_zencoder(video)</code>方法為示例目的。</p>
      </li>
      <li>這<code translate="No">submit_to_zencoder</code>函數看起來像這樣。這應該在後台異步運行。
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def submit_to_zencoder(video)
begin
response = Zencoder::Job.create(attributes, :timeout =&gt; 30_000)
if response.code == 201
video.state = "transcoding"
else
video.state = "pending"
end

video.save!

# Rescue any connection error. Our plugin abstracts these as
# Zencoder::HTTPError.
#
# If you're not using the Zencoder plugin, this includes things
# like Errno::ECONNRESET, Errno::ETIMEDOUT, Errno::ECONNREFUSED,
# Errno::EHOSTDOWN, and SocketError.

rescue Timeout::Error, Zencoder::HTTPError
video.state = "pending"
video.save!
end
end</code></pre>
      </li>
      <li>每隔一段時間-例如每分鐘-嘗試重新提交處於「待決' 狀態」的作業。
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def resubmit_pending_jobs
Video.where(:state =&gt; "pending").find_each do |video|
begin
video.state = "submitting"
video.save!

submit_to_zencoder(video)
rescue ActiveRecord::StaleObjectError
end
end
end
</code></pre>

        <p>此外，通過在視頻表中添加一個 'lock_version ' 列，我們引入樂觀的鎖定。這意味著，如果記錄在<code translate="No">Video.find</code>查詢和<code translate="No">video.save</code>，它不會將作業提交給Zencoder。這樣可以防止意外將作業兩次提交給Zencoder。您可以使用悲觀鎖定或數據庫鎖定或其他某種鎖定方法來完成同一件事。</p>

        <h2>就這麼簡單...</h2>

        <p>考慮到所有因素，這是一種非常簡單的方法，可確保Zencoder和您的應用程序之間100％集成的可靠性。這比僅僅天真地提交工作要多一些步驟。但它可以確保無論發生什麼情況-無論是偶爾的超時，Zencoder的意外停機還是計劃的維護-您的應用程序都能可靠運行。</p>
      </li>
    </ol>
  </section>
</article>